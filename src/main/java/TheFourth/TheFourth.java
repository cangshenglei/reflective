package TheFourth;

public class TheFourth {
    static int num = 1;

    public static void main(String[] args) {
        method();
        /*
	死循环:在程序中,通过循环条件语句无法停止下来的循环

	分类:
		for死循环格式
			for (;;) {
				循环体语句
			}
		while死循环格式
			while (true) {
				循环体语句
			}

	应用场景:
		无法确认循环的条件语句时,直接让循环语句进行死循环,当满足某个条件的时候,再进行break结束循环语句

	在实际开发中,for和while的死循环格式如何选择?
		推荐使用while死循环格式,程序的阅读性更好;如果编写的程序是计算机语言源码,框架源码,插件源码,算法等,更推荐使用for死循环格式,执行效率更高,在平时开发中可以将这一特点可以忽略不计(硬件性能过剩)
*/

        /*
	循环嵌套:在程序的循环语句中,出现了另外的一个循环语句

	需求:按照固定的格式打印1天中的时间
		0时0分~23时59分

	循环嵌套的特点:
		1.循环嵌套往往指代的是for循环嵌套语句
		2.将外层循环语句称之为"外层循环"
		  将内层循环语句称之为"内层循环"
		3.外层循环和内层循环是一对相对的概念
		4.在实际应用的过程中,当循环语句嵌套3层以上的,往往有更简便的方式
		5.在循环嵌套中,外层循环的初始化语句执行了(1)次
		6.在循环嵌套中,内层循环的初始化语句执行了(外层循环次数)次
		7.在循环嵌套中,内层循环的循环体语句执行了(外层循环次数*内层循环次数)次

	循环嵌套的格式:
		for (外层循环的初始化语句;外层循环的循环条件语句;外层循环的迭代语句) {
			for (内层循环的初始化语句;内层循环的循环条件语句;内层循环的迭代语句) {
				内层循环的循环体语句
			}
		}

	执行流程:
		1.先执行外层循环的初始化语句;
		2.确认外层循环的循环条件语句是true还是false;
		3.如果是true,执行内层循环语句(执行第a步);
			a.执行内层循环的初始化语句;
			b.确认内层循环的循环条件语句是true还是false;
			c.如果是true,执行内层循环的循环条件语句;
			  如果是false,内层循环语句结束,继续执行第4步
			d.执行内层循环的迭代语句;
			e.跳回第b步继续执行
		  如果是false,循环嵌套语句结束;
		4.执行外层循环的迭代语句;
		5.跳回第2步,继续执行
*/
/*
	方法:在程序中封装特殊功能的代码块

	方法的好处:
		1.提高代码的复用性,从而提高开发效率
		2.降低代码的耦合性
			耦合性:代码与代码之间的关联,关联性越大,耦合性越大,关联系越小,耦合性越小
*/

/*
	方法的格式:
		修饰符 返回类型 方法名 (形参类型1 形参名1,形参类型2 形参名2,......,形参类型n 形参名n) {
			方法体语句
			return 返回值;
		}

		修饰符:针对内容修饰的关键字,目前阶段,修饰符不是重点,固定使用public static替代
		返回类型:返回结果的数据类型
			无返回类型
			基本类型
			引用类型
		方法名:标识符,就是给方法起的名字,做到"见名知意"
		():形参列表
			什么都没有
			基本类型
			引用类型
		方法体语句:特殊功能的代码块
		return:(1)结束方法(2)如果return后面存在返回值,在结束方式的同时将返回值进行返回
		返回值:返回的结果数据

	返回(自定义方法==>调用者方法):
		当调用者方法需要使用自定义方法中的结果数据值,无法直接获取,需要返回的方式将结果数据进行返回
	传参(调用者方法==>自定义方法):
		当自定义方法需要使用调用者方法中的数据时,无法直接获取,需要通过参数传递的方式将数据进行传递
*/
/*
	声明方法前的两个明确
		返回类型:明确方法返回值的数据类型
		形参列表:明确需要用到调用者方法中的几个数据,且每个数据是什么数据类型

	需求:通过方法获取两个整数的累加和
*/

/*
        方法的特点:
        不调用,不执行

        方法调用方式:
        1.如果方法归属于对象,调用格式:
        对象名.方法名(实参);
        2.如果方法归属于类,调用格式:
        类名.方法名(实参);
        3.如果调用同一个类中的方法,调用格式:
        单独调用(直接调用):
        方法名(实参);
        输出调用(打印调用):
        System.out.println(方法名(实参));
        赋值调用:
        数据类型 变量名 = 方法名(实参);
*/

/*
	方法的重载
		在同一个类中(或者子父类继承关系中),出现了方法名相同,形参列表不同的现象

	方法重载的前提条件:
		1.必须在同一个类中或者子父类继承关系中
		2.必须方法名相同
		3.必须形参列表不同(至少满足以下一点)
			(1)形参列表中参数的数据类型不同
			(2)形参列表中参数的个数不同
			(3)形参列表中参数数据类型顺序不同
*/

/*
	方法重载的注意事项:
		在方法重载的时候,具体调用哪个方法取决于方法的实参
*/

/*
	方法的递归:
		在程序中方法自身调用自身的现象

	分类:
		直接递归:
			方法自身调用自身
		间接递归:
			方法A调用方法B,方法B调用方法C,方法C调用方法A

	方法递归的前提条件:
		如果使用递归进行特殊的循环,需要给递归添加限定条件,否则会发生栈内存溢出
		如果使用递归进行特殊的循环,即使添加限定条件,也不能让递归的层数太多,否则会发生栈内存溢出

	递归的好处:
		递归是一种特殊的循环,在实际应用中,往往会有一些场景无法使用for和while语句进行遍历,
		只能通过递归进行解决
			举例:多级文件夹的复制
*/

/*
	通过方法打印指定次数的HelloWorld

	void关键字:
		在程序中表示方法没有返回值

	void的注意事项:
		1.当方法没有合适的返回值时,返回类型的位置也不能空着,需要void关键字进行占位
		2.当方法的返回类型是void时,方法的调用方式只能是单独调用
		3.当方法的返回类型是void时,方法体后面的return关键字可以省略不写
*/

/*
	方法的小结:
		1.在程序中,方法与方法时平级的关系,无法进行方法声明的嵌套
		2.在程序中,方法所在的位置必须是类文件(class,interface,enum)中
		3.方法的特点,不调用不执行
		4.当方法没有合适的返回值时,返回类型的位置也不能空着,需要void关键字进行占位
		5.当方法的返回类型是void时,方法的调用方式只能是单独调用
		6.当方法的返回类型不是void时,方法的调用格式推荐使用赋值调用
		7.当方法的返回类型是void时,方法体后面的return关键字可以省略不写
*/
    }
    public static void method () {
        System.out.println(num++);

        if (num == 10) {
            return;//结束方法
        }

        method();
    }
}


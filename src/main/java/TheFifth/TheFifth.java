package TheFifth;

public class TheFifth {
    /**
     * @ClassName ArrayDemo01
     * @Description 此类用于演示功能
     * @Author Shark
     * @DateTime 2022年02月18日 14时08分
     * @Version 1.0
     *
     * 数组:在程序中存储同一种数据类型多个元素的固定容器
     *
     * 数组的前提条件:
     *      1.数组一旦进行初始化其长度是固定不变的
     *      2.数组中的元素在内存中必须是同一种数据类型
     *      3.数组中的元素个数必须是多个
     *      (在程序中可以声明初始化长度为0或者1的数组,但是这样的数组没有任何意义)
     */
    /**
     * @ClassName ArrayDemo02
     * @Description 此类用于演示功能
     * @Author Shark
     * @DateTime 2022年02月18日 14时18分
     * @Version 1.0
     *
     * 数组的声明初始化
     *
     * 数组的声明:
     *      数据类型[] 数组名;(推荐)
     *      数据类型 数组名[];
     *
     * 数组的初始化:
     *      动态初始化:初始化数组的时候只初始化数组的长度,不会初始化数组里面的具体数据值,JVM可以直接获取数组的长度
     *          格式:
     *              数据类型[] 数组名 = new 数据类型[数组长度];
     *
     *      静态初始化:初始化数组的时候只初始化数组里面的具体数据值,不会初始化数组的长度,JVM可以间接获取数组的长度
     *          标准格式:
     *              数据类型[] 数组名 = new 数据类型[]{元素1,元素2,......,元素n};
     *          简化格式:
     *              数据类型[] 数据名 = {元素1,元素2,......,元素n};
     *
     * 数组声明初始化的名词解释:
     *      数据类型:数组中元素的数据类型
     *      []:声明的是一维数组
     *      数据类型[]:数组的数据类型
     *      数组名:数组的名字
     *      new:向内存申请并开辟合适内存空间
     *      数组长度:数组中可以存储多少个元素
     *
     * 数组声明初始化的注意事项:
     *      1.数组的动态初始化和静态初始化没有推荐一说,需要根据实际需求再进行决定使用哪种初始化的方式
     *      2.在程序中不允许通过动静结合的方式进行数组的声明初始化
     *      3.在数组中的元素支持变量的类型转换
     *      4.数组静态初始化的简化格式不允许先声明,后初始化
     *          原因:变量的声明初始化,初始化值是多少取决于变量名前的数据类型,静态初始化的标准格式先声明后初始化,通过new申请并开辟
     *          内存空间,静态初始化的简化格式直接声明初始化,JVM根据变量名前面的数据类型自动给其申请并开辟内存空间,静态初始化的简化
     *          格式先声明后初始化,JVM无法直接获取到前面的数据类型,所以给其申请并开辟内存空间,导致编译报错
     *
     * 数组声明初始化的面试题?
     *      数组静态初始化标准版和简化版的区别?
     *      数组动态初始化和静态初始化的区别?
     *
     */
    /**
     * @ClassName ArrayDemo03
     * @Description 此类用于演示功能
     * @Author Shark
     * @DateTime 2022年02月18日 15时07分
     * @Version 1.0
     *
     * 数组的使用:
     *      获取数组中的元素
     *      获取数组的长度
     *
     * 获取数组中的元素:
     *      需要通过"索引值"进行获取
     *      索引值:针对数组中的元素按照一定的规则进行的数字编号
     *      索引值的规则:
     *          元素编号从0开始,一直到数组的长度-1,长度为0的数组不存在索引值
     *      格式:
     *          数组名[索引值]
     *
     * 获取数组的长度
     *      数组名.length
     *
     */
    /**
     * @ClassName ArrayDemo04
     * @Description 此类用于演示功能
     * @Author Shark
     * @DateTime 2022年02月18日 15时24分
     * @Version 1.0
     *
     * JVM内存划分方式一共存在3种:
     *      JDK6.0(包含)以前
     *      JDK7.0(可以忽略不计)
     *      JDK8.0(包含)以后
     *
     * JDK6.0(包含)以前内存划分方式
     *      程序计数器(寄存器):负责和CPU相关的内容,和开发关系不大
     *      本地方法栈:负责和操作系统相关的内容,和开发关系不大
     *      栈内存:存储的正在运行的方法
     *      堆内存:存储new出来的东西
     *      方法区:存储并处理字节码文件对象,包含:字节码文件区,静态区,常量区
     *
     * JDK8.0(包含)以后内存划分方式:
     *      程序计数器(寄存器):负责和CPU相关的内容,和开发关系不大
     *      本地方法栈:负责和操作系统相关的内容,和开发关系不大
     *      栈内存:存储的正在运行的方法
     *      堆内存:存储new出来的东西和方法区
     *
     * 回顾栈内存的特点:
     *      1.方法先进后出,后进先出
     *      2.方法一旦被调用立刻进栈,一旦结束调用立刻出栈
     *
     * 堆内存的特点:
     *      1.堆内存中的每块内存区域都有分配的地址值
     *      2.堆内存中每块内存区域中的变量都有默认值
     *          整数类型        默认值:0
     *          浮点类型        默认值:0.0
     *          字符类型        默认值:'\u0000'
     *          布尔类型        默认值:false
     *          引用类型        默认值:null
     *      3.一旦new立刻在堆内存申请并开辟内存区域(进堆),new出来的内存区域和其它内存没有任何关联不会在堆内存中立刻消失,
     *      会标记为"垃圾数据"
     *      4.在堆内存中有一条独立线程,被称之为"垃圾回收器",垃圾回收器可以理解为生活中的"扫地机器人",垃圾回收器会根据设定
     *      的扫描规则不间断的扫描堆内存中的各个区域,一旦发现垃圾数据,立刻进行回收(清理),回收后,new出来的区域才彻底在堆内
     *      存中消失
     *
     */
    /**
     * @ClassName ArrayDemo08
     * @Description 此类用于演示功能
     * @Author Shark
     * @DateTime 2022年02月18日 16时33分
     * @Version 1.0
     *
     * 数组中的三个异常:
     *      1.NegativeArraySizeException异常:数组长度为负异常
     *          产生原因:动态创建数组时长度为负数
     *      2.ArrayIndexOutOfBoundsException:数组索引越界异常
     *          产生原因:访问错误或者不存在的索引
     *      3.NullPointerException异常:空指针异常
     *          产生原因:通过null获取数组元素或者对象成员
     */
    /**
     * @ClassName ArrayDemo09
     * @Description 此类用于演示功能
     * @Author Shark
     * @DateTime 2022年02月18日 16时42分
     * @Version 1.0
     *
     * 数组的应用:
     *      基础应用:针对数组中元素的位置不进行任何改变,通过查询做数组元素的操作
     *          举例:获取所有元素的最大值,最小值,获取数组所有元素的累加和......
     *      高级应用:不依赖于其它数组,针对数组中元素位置进行一定规则的改变
     *          举例:反转,排序....
     *      综合应用:数组和方法的综合应用
     *          举例:数组的动态扩容,动态插入,动态删除.....
     *
     * 需求:按照固定的格式拼接数组中的元素,并打印
     *      固定格式:
     *          数组:[11, 22, 33, 44, 55]
     */

    /**
     * @ClassName ArrayDemo08
     * @Description 此类用于演示功能
     * @Author Shark
     * @DateTime 2022年02月18日 16时33分
     * @Version 1.0
     *
     * 数组中的三个异常:
     *      1.NegativeArraySizeException异常:数组长度为负异常
     *          产生原因:动态创建数组时长度为负数
     *      2.ArrayIndexOutOfBoundsException:数组索引越界异常
     *          产生原因:访问错误或者不存在的索引
     *      3.NullPointerException异常:空指针异常
     *          产生原因:通过null获取数组元素或者对象成员
     */
    public static void main(String[] args) {
        int[] arr = new int[3];
        System.out.println(arr[0]);

        String[] str = new String[3];
        System.out.println(str[0]);
    }
}

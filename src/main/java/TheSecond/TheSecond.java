package TheSecond;

public class TheSecond {
    public static void main(String[] args) {
        /*
	类型转换:数据类型之间的转换

	分类:
		基本类型间的转换
		引用类型间的转换
		基本类型和包装类型间的转换
		基本类型和字符串类型间的转换

	基本类型间的转换
		基本类型可以根据"取值范围"进行对应的转换

	基本类型间转换的分类:
		自动转换(隐式转换)
		强制转换(显式转换)


*/
        /*
	基本类型间的自动转换(隐式转换)
		将取值范围较小的数据类型转换成取值范围较大的数据类型

	基本类型取值范围从小到大的关系:
		byte < short < int < long < float < double
				char < int < long < float < double

	面试题:
		在内存中float类型变量占4个字节,long类型变量占8个字节,为什么float类型的取值范围比long的取值范围更大?
			1.基本类型间转换和占用字节大小无关,只能取值范围有关
			2.float类型底层是IEEE754浮点算数标准,而long类型底层是十进制数字,浮点算数标准规则可以存储整数十进制的数字
			3.通过数学验证float类型的取值范围大于long类型的取值范围
				long类型取值范围中最大的整数是2^63 - 1 < 2^63
				float类型取值范围中较大的整数值是3.4 * 10^38

				3.4*10^38 > 2*10^38 > 2*8^38 = 2*(2^3)^38 = 2*2^114 = 2^115
*/
        byte num01 = 1;
        char num02 = 'a';
        short num03 = 123;

        num03=num01;
    /*    num02=num01;
        num01=num02;*/
        System.out.println("" + 'a' + 1);
        byte num = (byte)130;
        //byte的取值范围 -128 -127 -126 ...... 0 ...... 125 126 127
        //130 = 127 + 3
        System.out.println(num);
        float f1 = 1.1F;
        float f2 = 3.4F;
        float f3 = f1 + f2;
        System.out.println(f3);


        byte b1 = 3;
        byte b2 = 4;

        System.out.println(b1+b2);
        /*
	常量:在程序中其值不可以发生改变的量

	分类:
		字面值常量:就是单独的一个值,没有实际意义,需要结合代码有意义
			整数字面值常量
			浮点字面值常量
			布尔字面值常量
			字符字面值常量
			字符串字面值常量
			空常量(暂不涉及,后面讲解)
		自定义常量(暂不涉及,后面讲解)
*/
        /*
	常量的注意事项
		1.当声明初始化byte,short,char类型变量时,当右面的初始化值是字面值常量,且该字面值常量还在其数据类型的取值范围内,JVM自动会在编译时期自动将这个字面值常量优化为该数据类型,我们将这一过程称之为"常量优化机制"
		2.当进行数学运算的时候,运算符号两边都是字面值常量,且运算后的结果还在其数据类型的取值范围内,JVM自动会在编译时期自动将该运算运算完毕,我们将这一过程也称之为"常量优化机制"
*/

     /*
	两种常见的输出语句:
		换行输出语句:输出语句先输出内容,在进行换行操作
		直接输出语句:输出语句直接输出内容,不进行其它操作

	格式:
		换行输出语句:
			System.out.println(输出内容);

		直接输出语句:
			System.out.print(输出内容);

	注意事项:
		换行输出语句里面的输出内容可以不写,直接进行换行操作
		直接输出语句里面不可以什么都不写
*/

     /*
	运算符:在程序中用来连接变量或常量的运算符号
	表达式:在程序中用运算符连接起来的式子
		举例: a + b

	运算符的分类
		算数运算符
		赋值运算符
		关系运算符
		逻辑运算符
		三元运算符
		位运算符
*/
         /*
	算数运算符:在程序中针对常量或变量进行数学运算的运算符

	包含:
		+ - * / % ++ --

	/ 和 % 的区别:
		/ : 获取两个数相除的商
		% : 获取两个数相除的余数
*/

         /*
	自增自减运算符:
		++:在变量自身数据值的基础上进行+1运算操作,再将结果赋值给该变量
		--:在变量自身数据值的基础上进行-1运算操作,再将结果赋值给该变量

	格式:(以++为例)
		变量名++
		++变量名

	特点:
		1.单独使用的特点
			++在前和++在后的结果是一样的
		2.复合使用的特点
			++在前,先自增,后使用
			++在后,先使用,后自增
*/

         /*
	获取一个四位数的个位，十位，百位，千位

	获取指定位上的数字其实就是用这个数字除以这个位上的权重,再对10进行取余
*/

         /*
	赋值运算符:针对变量进行赋值运算的运算符

	分类:
		基本赋值运算符:=
		扩展赋值运算符:+= -= *= /= %=
			含义:进行扩展赋值运算符的运算时,将运算符两边的变量进行运算操作(是什么运算,取决于除了=另外的符号),将运算后的结果再赋值给左边的变量
*/
/*
	赋值运算符的注意事项:
		1.扩展的赋值运算符,将运算后的结果赋值给左边的变量之前,会根据左边变量的数据类型隐式进行强制类型转换
		2.进行扩展赋值运算符运算的时候,如果右边是一个式子的,需要先将这个式子运算完毕后,再进行扩展赋值运算符的操作
*/

/*
	关系运算符:判断变量间关系的运算符号

	包含:
		> >= < <= == !=

	注意事项:
		1.关系表达式的结果一定是boolean值
		2.如果是两个符号的关系运算符,必须连在一起进行编写,否则编译报错
		3.千万不要将==写成=,也不要将=写成==

	==:判断两个基本类型变量的值是否相等
	!=:判断两个基本类型变量的值是否不等
*/

/*
	逻辑运算符:将关系表达式与关系表达式之间构成一定的逻辑关系的运算符

	分类:
		基本逻辑运算符
			&	|	^	!
		短路逻辑运算符
			&&	||

	基本逻辑运算符:
		& : 与,且	结论:有false则false
		应用场景:判断多个条件是否同时满足

		| : 或		结论:有true则true
		应用场景:判断多个条件是否至少满足一个

		^ : 异或	结论:相同为false,不同为true
		应用场景:判断多个条件是否不同

		! : 非		结论:非true则false,非false则true
		应用场景:将条件的结果进行取反
*/

/*
	短路逻辑运算符:
		&& : 双与,短路与
		|| : 双或,短路或

	& 和 && 区别:
		& 和 && 的结果是一样的,&&具有短路的效果,当&&前面的表达式结果为false的时候,后面的表达式不会被执行;&前面的表达式的结果无论是true还是false,后面表达式都会被执行,在实际开发中推荐使用&&

	| 和 || 区别:
		| 和 || 的结果是一样的,||具有短路的效果,当||前面的表达式结果为true的时候,后面的表达式不会被执行;|前面的表达式的结果无论是true还是false,后面表达式都会被执行,在实际开发中推荐使用||
*/

/*
	三元运算符:
		含有三位未知量的运算符

	格式:
		关系表达式 ? 结果值1 : 结果值2

	执行流程:
		1.先看关系表达式的结果是true还是false;
		2.在确定关系表达式结果的同时,统一结果值1和结果值2的数据类型
		3.如果关系表达式的结果是true,执行结果值1;
		  如果关系表达式的结果是false,执行结果值2

*/

/*
	原码,反码,补码
		相同点:
			都是数据对应的定点二进制表示方式;
			根据数据对应的存储字节转换成二进制位进行足位,不足位,前面需要0进行补位,该二进制的最高为为符号位,0表示正数,1表示负数
		不同点:
			原码:是显式数据对应的二进制足位表示
			反码:通过反码进行原码和补码之间的转换
			补码:在计算机中一切数据的计算都拿数据的补码进行进行计算

	数据存储和运算过程:
		1.将十进制数据转换成原码二进制
		2.数据的原码转换成数据的反码
			如果数据是正整数:其反码和原码是一致的
			如果数据是负整数:其反码就是在原码的基础上进行逐位取反(符号位保持不变)
		3.数据的反码转换成数据的补码
			如果数据是正整数:其补码和反码是一致的
			如果数据是负整数:其补码就是在反码的基础上进行+1运算
		4.根据补码进行运算获取到结果的补码
		5.结果的补码转换成结果的反码
			如果结果是正整数:其反码和补码是一致的
			如果结果是负整数:其反码就是在补码的基础上进行-1运算
		6.结果的反码转换成结果的原码
			如果结果是正整数:其原码和反码是一致的
			如果结束时负整数:其原码就是在反码的基础上进行逐位取反(符号位保持不变)
		7.结果的原码转换成十进制数据

	将int类型的130强转为byte类型后,结果为-126

	过程分析:
		1.获取130的原码
			数据的原码:00000000 00000000 00000000 10000010
		2.根据130的原码获取其反码
			数据的反码:00000000 00000000 00000000 10000010
		3.根据130的反码获取其补码
			数据的补码:00000000 00000000 00000000 10000010
		4.将int类型强转为byte类型
			结果的补码:10000010
		5.根据结果的补码获取其反码
			结果的反码:10000001
		6.根据结果的反码获取其原码
			结果的原码:11111110
		7.根据结果的原码获取其十进制数据
			十进制数据:-126
*/

/*
	位运算符:
		在程序中针对二进制位进行操作的运算符

	分类:
		按位运算符
			&	|	^	~
		移位运算符
			<<	>>	>>>

	注意事项:
		&,|,^这三个运算符是Java中典型的"墙头草",看运算符的两边如果是boolean值的话,它们就是"逻辑运算符";如果两边是数值的话,它们就是"位运算符"

	按位运算符:
		&:按位与,当两位相同为1时才返回1
		|:按位或,只要有一位为1即可返回1
		^:按位异或,当两位相同时返回0,不同时返回1(包含符号位)
		~:按位非:将操作数的每个位全部取反(包含符号位)

	移位运算符:
		<<:左移运算符
			格式:
				数据 << 移动位数
			特点:
				将二进制数据往左移动指定位数,符号位也随之移动,如果低位出现了空位,以0进行补位
		>>:右移运算符:
			格式:
				数据 >> 移动位数
			特点:
				将二进制数据往右移动指定位数,符号位也随之移动,如果高位出现了空位,
				以和符号位相同的数字进行补位
		>>>:无符号右移运算符:
			格式:
				数据 >>> 移动位数
			特点:
				将二进制数据往右移动指定位数,符号位也随之移动,如果高位出现了空位,
				以0进行补位

	学习位运算符的目的:
		1.查询源码
		2.面试
			举例:数字2以哪种方式最快运算成16
				2 << 3
*/
    }


    /*
	基本类型间的强制转换(显式转换)
		将取值范围较大的数据类型转换成取值范围较小的数据类型

	格式:
		取值范围较小的数据类型 变量名 = (取值范围较小的数据类型)取值范围较大的数据类型的数据值;
*/

    /*
	基本类型转换的注意事项:
		1.基本类型转换是七种数值类型间的转换,boolean类型变量无法进行转换
		2.在实际应用中尽量避免使用强制类型转换,可能发生数据的损失和数据的溢出
		3.基本类型中有三个特殊类型byte,short,char,这三种数据类型只要参与数学运算,先将这三种类型的变量提升成int类型变量,再参与数学运算;如果没有数学运算操作,该三种数据类型依然遵循基本类型的自动转换和强制转换规则
*/

    /*
	+ 号的多种用法:
		1.加法运算符
		2.字符串连接符
			当+号两边中的任意一边出现字符串的话,+号不再起到加法运算的操作,而是进行字符串的连接,将两边的内容直接进行合并,获取到新的字符串
*/
/*
	运算符的优先级
		1.不要把一个表达式写得过于复杂，如果一个表达式过于复杂，则把它分成几步来完成；
		2.不要过多的依赖运算的优先级来控制表达式的执行顺序，这样可读性太差，尽量使用()来控制表达式的执行顺序
		3.在程序中提高优先级,()可以进行嵌套
*/
}
